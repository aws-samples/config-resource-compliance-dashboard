AWSTemplateFormatVersion: '2010-09-09'
Description: 'CRCD - AWS Config custom rule to detect IAM users with active access keys'

Resources:
  # IAM Role for Lambda function
  ConfigRuleLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'crcd-cirt-user-access-key-lambda-role-${AWS::Region}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ConfigRulePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - config:PutEvaluations
                  - config:GetResourceConfigHistory
                Resource: '*'
              - Effect: Allow
                Action:
                  - iam:ListAccessKeys
                Resource: '*'

  # Lambda function
  ConfigRuleLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'crcd-cirt-user-access-key-${AWS::Region}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ConfigRuleLambdaRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import botocore
          import boto3
          import datetime
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ASSUME_ROLE_MODE = False

          def lambda_handler(event, context):
              global AWS_CONFIG_CLIENT

              check_defined(event, 'event')
              logger.debug('CRCD-CIRT: Received event: ' + json.dumps(event))

              invoking_event = json.loads(event['invokingEvent'])
              logger.debug('CRCD-CIRT: Received invoking event: ' + json.dumps(invoking_event))

              rule_parameters = {}
              if 'ruleParameters' in event:
                  rule_parameters = json.loads(event['ruleParameters'])

              compliance_value = 'NOT_APPLICABLE'
              AWS_CONFIG_CLIENT = get_client('config', event)

              configuration_item = get_configuration_item(invoking_event)
              logger.debug('CRCD-CIRT: Received configuration item: ' + json.dumps(configuration_item))
              
              if is_applicable(configuration_item, event):
                  compliance_value = evaluate_change_notification_compliance(
                          configuration_item, rule_parameters, event)

              response = AWS_CONFIG_CLIENT.put_evaluations(
                 Evaluations=[
                     {
                         'ComplianceResourceType': invoking_event['configurationItem']['resourceType'],
                         'ComplianceResourceId': invoking_event['configurationItem']['resourceId'],
                         'ComplianceType': compliance_value,
                         'OrderingTimestamp': invoking_event['configurationItem']['configurationItemCaptureTime']
                     },
                 ],
                 ResultToken=event['resultToken'])

          def evaluate_change_notification_compliance(configuration_item, rule_parameters, event):
              check_defined(configuration_item, 'configuration_item')
              check_defined(configuration_item['configuration'], 'configuration_item[\'configuration\']')
              if rule_parameters:
                  check_defined(rule_parameters, 'rule_parameters')

              resource_type = configuration_item['resourceType']
              
              if resource_type == 'AWS::IAM::User':
                  iam_client = get_client('iam', event)
                  user_name = configuration_item['resourceName']
                  logger.info('CRCD-CIRT: checking IAM user ' + user_name)
                  
                  try:
                      response = iam_client.list_access_keys(UserName=user_name)
                      access_keys = response.get('AccessKeyMetadata', [])
                      
                      active_keys = [key for key in access_keys if key['Status'] == 'Active']
                      logger.info('CRCD-CIRT: Access keys found: ' + str(len(access_keys)) + ', Active keys: ' + str(len(active_keys)))
                      
                      if active_keys:
                          return 'NON_COMPLIANT'
                      return 'COMPLIANT'
                  except Exception:
                      return 'NOT_APPLICABLE'
              
              return 'NOT_APPLICABLE'

          def check_defined(reference, reference_name):
              if not reference:
                  raise Exception('Error: ', reference_name, 'is not defined')
              return reference

          def get_client(service, event):
              if not ASSUME_ROLE_MODE:
                  return boto3.client(service)
              credentials = get_assume_role_credentials(event["executionRoleArn"])
              return boto3.client(service, aws_access_key_id=credentials['AccessKeyId'],
                                  aws_secret_access_key=credentials['SecretAccessKey'],
                                  aws_session_token=credentials['SessionToken'])

          def get_assume_role_credentials(role_arn):
              sts_client = boto3.client('sts')
              try:
                  assume_role_response = sts_client.assume_role(RoleArn=role_arn, RoleSessionName="configLambdaExecution")
                  return assume_role_response['Credentials']
              except botocore.exceptions.ClientError as ex:
                  if 'AccessDenied' in ex.response['Error']['Code']:
                      ex.response['Error']['Message'] = "AWS Config does not have permission to assume the IAM role."
                  else:
                      ex.response['Error']['Message'] = "InternalError"
                      ex.response['Error']['Code'] = "InternalError"
                  raise ex

          def get_configuration_item(invokingEvent):
              check_defined(invokingEvent, 'invokingEvent')
              if is_oversized_changed_notification(invokingEvent['messageType']):
                  configurationItemSummary = check_defined(invokingEvent['configurationItemSummary'], 'configurationItemSummary')
                  return get_configuration(configurationItemSummary['resourceType'], configurationItemSummary['resourceId'], configurationItemSummary['configurationItemCaptureTime'])
              return check_defined(invokingEvent['configurationItem'], 'configurationItem')

          def is_oversized_changed_notification(message_type):
              check_defined(message_type, 'messageType')
              return message_type == 'OversizedConfigurationItemChangeNotification'

          def get_configuration(resource_type, resource_id, configuration_capture_time):
              result = AWS_CONFIG_CLIENT.get_resource_config_history(
                  resourceType=resource_type,
                  resourceId=resource_id,
                  laterTime=configuration_capture_time,
                  limit=1)
              configurationItem = result['configurationItems'][0]
              return convert_api_configuration(configurationItem)

          def convert_api_configuration(configurationItem):
              for k, v in configurationItem.items():
                  if isinstance(v, datetime.datetime):
                      configurationItem[k] = str(v)
              configurationItem['awsAccountId'] = configurationItem['accountId']
              configurationItem['ARN'] = configurationItem['arn']
              configurationItem['configurationStateMd5Hash'] = configurationItem['configurationItemMD5Hash']
              configurationItem['configurationItemVersion'] = configurationItem['version']
              configurationItem['configuration'] = json.loads(configurationItem['configuration'])
              if 'relationships' in configurationItem:
                  for i in range(len(configurationItem['relationships'])):
                      configurationItem['relationships'][i]['name'] = configurationItem['relationships'][i]['relationshipName']
              return configurationItem

          def is_applicable(configurationItem, event):
              try:
                  check_defined(configurationItem, 'configurationItem')
                  check_defined(event, 'event')
              except:
                  return True
              
              status = configurationItem['configurationItemStatus']
              eventLeftScope = event['eventLeftScope']
              if status == 'ResourceDeleted':
                  logger.info("CRCD-CIRT: Resource Deleted, setting Compliance Status to NOT_APPLICABLE.")
              
              return (status == 'OK' or status == 'ResourceDiscovered') and not eventLeftScope

  # Lambda permission for Config to invoke the function
  ConfigRuleLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ConfigRuleLambdaFunction
      Action: lambda:InvokeFunction
      Principal: config.amazonaws.com
      SourceAccount: !Ref AWS::AccountId

  # AWS Config Rule
  ConfigRule:
    Type: AWS::Config::ConfigRule
    DependsOn: ConfigRuleLambdaPermission
    Properties:
      ConfigRuleName: crcd-cirt-user-access-key
      Description: 'Users with long-term access keys are NON COMPLIANT.'
      Source:
        Owner: AWS_LAMBDA
        SourceIdentifier: !GetAtt ConfigRuleLambdaFunction.Arn
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
            MaximumExecutionFrequency: TwentyFour_Hours
      Scope:
        ComplianceResourceTypes:
          - AWS::IAM::User
      EvaluationModes:
        - Mode: DETECTIVE

Outputs:
  ConfigRuleName:
    Description: 'Name of the AWS Config rule'
    Value: !Ref ConfigRule
  
  LambdaFunctionArn:
    Description: 'ARN of the Lambda function'
    Value: !GetAtt ConfigRuleLambdaFunction.Arn
    
  IAMRoleArn:
    Description: 'ARN of the IAM role for Lambda'
    Value: !GetAtt ConfigRuleLambdaRole.Arn